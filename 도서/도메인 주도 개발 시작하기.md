# 도메인 주도 개발 시작하기
- [1. 도메인 모델 시작하기](#1-도메인-모델-시작하기)
- [2. 아키텍처 개요](#2-아키텍처-개요)
- [3. 애그리거트](#3-애그리거트)
- [4. 리포지토리와 모델 구현](#4-리포지토리와-모델-구현)
- [5. 스프링 데이터 JPA를 이용한 조회 기능](#5-스프링-데이터-jpa를-이용한-조회-기능)
- [6. 응용 서비스와 표현 영역](#6-응용-서비스와-표현-영역)
- [7. 도메인 서비스](#7-도메인-서비스)
- [8. 애그리거트 트랜잭션 관리](#8-애그리거트-트랜잭션-관리)
- [9. 도메인 모델과 바운디드 컨텍스트](#9-도메인-모델과-바운디드-컨텍스트)

# 1. 도메인 모델 시작하기

## 도메인
소프웨어어로 해결하고자 하는 문제 영역

## 도메인 모델
- 특정 도메인을 개념적으로 표현한 것
- 도메인 자체를 이해하기 위한 개념 모델
  - 개념 모델 : 순수하게 문제를 분석한 결과물, 기술적인 부분은 고려하지 않음
  - 구현 모델 : 실제 코드를 작성할 때 사용
- 도메인 모델 도출은 요구사항 분석에서 시작

### 하위 도메인
- 도메인은 다수의 하위 도메인으로 구성
- 도메인에 따라 용어 의미가 결정 -> 하나의 다이어그램에 여러 하위 도메인을 모델링하면 안됨
  - 각 하위 도메인마다 별도로 모델을 생성해야 함

## 도메인 객체
- 생성하는 시점에 완전한 상태로 생성되어야 함
  - -> 생성 시점에 필요한 데이터를 모두 전달받고, `setter` 등으로 도메인 규칙 없이 값이 변경되는 것을 막아야 함
- 도메인에서 사용하는 용어를 최대한 코드에 반영해야 함



# 2. 아키텍처 개요

## 아키텍처 구성
### 사용자 인터페이스/표현
- 사용자의 요청을 처리하고 정보를 보여줌
- 사용자가 전송한 데이터 형식이 올바른지 검사, 문제 없다면 응용 서비스에 기능 실행 위임

### 응용
- 사용자가 요청한 기능을 실행
- 기능 수행을 위해 도메인 영역의 도메인 모델 사용
  - 응용 영역에서 업무 로직을 직접 구현하지 않음
  - 각 도메인의 규칙들을 호출, 도메인 모델에 로직 수행을 위임

### 도메인
- 도메인의 핵심 규칙 구현

### 인프라스트럭쳐
- 외부 시스템과의 연동 처리
- 구현 기술에 대한 것을 다룸

## 계층 구조 아키텍처
```
 _____       _____       ______       ____________
| 표현 | --> | 응용 | --> | 도메인 | --> | 인프라스트럭처 |
 -----       -----       ------       ------------
```
- 상위 -> 하위 의존 O
- 하위 -> 상위 의존 X

## DIP
**의존 역전 원칙 : Dependency Inversion Principle**
- 저수준 모듈이 고수준 모듈에 의존한다
- 하위 모듈을 추상화한 인터페이스는 고수준 모듈에 위치
  - 고수준 모듈에서는 구현체가 중요하지 않음
  - 인터페이스에서는 구체적인 구현체가 무엇인지 결정하지 않음

## 도메인 영역의 주요 구성요소
### 엔티티
- 식별자를 가짐
- 자신의 라이프 사이클을 가짐
- 도메인의 고유한 개념을 표현
- 데이터 + 관련 기능 제공

**도메인 모델의 엔티티 =/= DB의 엔티티**
- 도메인 모델의 엔티티 : 데이터 + 도메인 기능 제공
    - 도메인 관점에서 기능 구현, 캡슐화
    - 두 개 이상의 데이터가 개념적으로 하나인 경우, 밸류 타입으로 표현 가능
- DB의 엔티티 : 데이터 제공

### 밸류
- 식별자를 갖지 않음
- 개념적으로 완전한 하나를 표현할 때 사용 (여러 필드가 실제로는 하나의 개념을 표현)
- 엔티티 또는 다른 밸류 타입의 속성으로 사용됨
- 데이터 변경 기능을 제공하지 않음
  - 엔티티의 밸류 타입 데이터를 변경 = 객체 자체를 교체한다

### 애그리거트
- 연관된 엔티티, 밸류 객체를 개념적으로 하나로 묶은 군집
- 상위 수준에서 전체 모델의 관계와 개별 모델을 이해

#### 루트 엔티티
- 애그리거트에 속해 있는 엔티티, 밸류 객체를 이용해 애그리거트가 구현해야 할 기능을 제공
- 애그리거트 루트를 통해 내부의 다른 엔티티, 밸류 객체에 접근 가능
  - 내부 구현을 숨겨 애그리거트 단위로 구현을 캡슐화

### 리포지토리
- 도메인 모델의 영속성 처리
  - 구현을 위한 도메인 모델
- 애그리거트 단위로 엔티티 객체를 조회, 저장
  - 애그리거트가 개념상 완전한 한 개의 도메인
  - 애그리거트 루트를 위한 리포지토리만 존재
- 애그리거트의 상태가 변경되면, 모든 변경을 atomic하게 저장소에 반영해야 함
  - RDBMS : 트랜잭션을 이용
  - NoSQL (Mongo...) : 한 애그리거트를 한 문서에 함께 관리

### 도메인 서비스
- 특정 엔티티에 속하지 않는 도메인 로직 제공
- 여러 엔티티와 밸류를 사용해 로직 구현

## 모듈 구성
사용자 인터페이스(ui), 응용(application), 도메인(domain), 인프라스트럭처(infrastructure) 로 패키지 구성
- 도메인이 크면 하위 도메인 별 모듈 분리도 가능



# 3. 애그리거트
- 애그리거트 단위로 일관성 관리
  - 도메인 단순화
  - 한 애그리거트에 속한 객체는 유사하거나 동일한 라이프사이클을 가짐
- 경계가 명확
  - 한 애그리거트에 속한 객체는 다른 애그리거트에 속하지 않음
  - 여러 엔티티가 연관 관계를 맺고 있는 것 같아도, 라이프사이클이 동일하지 않거나, 한 엔티티의 변경이 다른 엔티티에 영향을 미치지 않다면 다른 애그리거트

한 트랜잭션에서는 하나의 애그리거트만 수정해야 함 = 애그리거트에서 다른 애그리거트를 변경하지 않음
- 애그리거트는 서로 독립적이어야 함
- 한 애그리거트가 다른 애그리거트에 의존하면 결합도가 높아짐
- -> 여러 애그리거트가 수정되어야 하는 경우, 응용 서비스에서 수정

## 애그리거트 루트
- 애그리거트에 속한 모든 객체가 정상 상태를 가지도록 책임을 지는 것 = 애그리거트의 일관성이 꺠지지 않도록 하는 것
  - 애그리거트 외부에서 애그리거트에 속한 객체를 직접 변경하면 안됨
    - 밸류 객체의 내부 상태를 변경하려면 루트를 통해서만 가능
- 각 구성요소의 상태만 참조하는 것은 아님, 내부 엔티티에 기능 실행을 위임하기도 함

## 애그리거트 간 연관
- 애그리거트에서 다른 애그리거트 참조 가능
  - 다른 애그리거트의 루트를 참조

JPA 등 ORM 기술에서 연관된 객체를 쉽게 참조할 수 있도록 함
- 문제점
    - 편한 탐색 오용 : 다른 애그리거트의 상태를 쉽게 변경할 수 있음
    - 성능 문제 : lazy loading, eager loading ...
    - 확장 : 하위 도메인마다 다른 DBMS를 사용할 때, 단일 기술 사용 불가
        - ID를 이용해 참조
            - 응용 서비스에서 ID를 이용해 로딩 == 지연 로딩과 동일
            - 조회 속도가 문제가 될 수 있음 (N+1)
                - 데이터 조회를 위한 DAO -> 조인을 사용해 한 번의 쿼리로 모두 로딩

컬렉션을 이용한 연관
- 1-N 연관
    - N 쪽에서 1 쪽의 ID를 참조
    - 그 연관을 통해 조회 가능
- M-N 연관
    - 개념적으로는 양방향 연관이라도, 요구사항을 고려하면 실제 구현에서는 단방향 연관만 적용할 수 있음

## 애그리거트를 팩토리로 이용하기
특정 애그리거트를 통해 다른 애그리거트 생성 가능 -> 팩토리 역할
- 여러 애그리거트가 연관된 기능 구현 시, 중요한 도메인 로직이 응용에 노출 가능
- 응용에 노출되었던 도메인 로직을 특정 팩토리 메소드 안에 넣을 수 있음
- 도메인 로직을 변경해도, 응용 서비스는 영향을 받지 않음

# 4. 리포지토리와 모델 구현

## JPA를 이용한 리포지토리 구현
- 리포지토리 인터페이스 - 도메인 영역
- 리포지토리 구현클래스 - 인프라스트럭쳐 영역

리포지토리 CRUD 기준은 애그리거트

## 스프링 데이터 JPA를 이용한 리포지토리 구현
스프링 데이터 JPA는 지정한 규칙에 맞게 인터페이스를 정의하면, 구현 객체를 알아서 만들어 스프링 빈에 등록해줌

## 매핑 구현
애그리거트 - JPA 매핑 기본 규칙
- 애그리거트 루트 = 엔티티 -> `@Entity`
- 밸류 - `@Embeddable`
- 밸류 타입 프로퍼티 - `@Embedded`
- 밸류를 이용한 ID - `@EmbeddedId`
    - implements Serializable
    - equals(), hashcode() 구현
- 별도 테이블에 저장하는 밸류 - `@SecondaryTable`, `@AttributeOverride` 사용

JPA 매핑 처리를 프로퍼티 방식이 아닌 필드 방식으로 선택
- 프로퍼티 방식 : public get/set 메소드 필요 -> 캡슐화를 깨는 원인

`@AttributeConverter`
- 두 개 이상의 프로퍼티를 가진 밸류 타입을 한 컬럼에 매핑 가능
- `AttributeConverter` 인터페이스의 구현 클래스는 `@Converter` 어노테이션 적용
- 적용 방법
    1. 구현 클래스의 `@Converter`  어노테이션 autoApply = true
    2. 매핑할 컬럼에 `@Convert` 로 컨버터 지정 가능

애그리거트 루트와 별도 테이플에 데이터를 저장한다고 엔티티인 것은 아님
- 엔티티 : 고유 식별자를 가짐
- 밸류 : 고유 식별자를 갖지 않음

엔티티가 확실하다면, 다른 애그리거트가 아닌지 확인해야 함

밸류 컬렉션을 `@Entity` 로 매핑하는 경우, 독자적인 라이프사이클 갖지 않고 애그리거트 루트에 의존
- cascade 속성 지정
    - cascade : 엔티티의 상태 변화를 전파
- orphanRemoval = true

## 애그리거트 로딩 전략
조회 시점에 애그리거트가 완전한 상태가 되려면, 즉시 로딩으로 설정

즉시 로딩
- 즉시 로딩의 이유
    - 상태 변경 시, 애그리거트 상태가 완전해야 함
    - 표현 영역에서 애그리거트 상태 정보 보여줄 때 필요
- 즉시 로딩의 문제점
    - 1-N, N-M 관계의 테이블까지 함께 조회하면, 쿼리 결과 중복 발생
        - cartesian join = cross join : 모든 경우의 수를 고려
- 문제점 해결 방법
    - 지연 로딩 : 트랜잭션 범위 내에서 실제로 상태를 변경하는 시점에 필요한 구성요소만 로딩, 적용
        - 쿼리 수행 횟수가 많아진다

## 애그리거트의 영속성 전파
애그리거트는 완전한 상태여야 함
- 저장 시, 애그리거트 루트만 저장하는 것이 아닌 애그리거트에 속한 모든 객체를 저장
- 삭제 시, 애그리거트 루트 뿐만 아니라 속한 모든 객체를 삭제

## 식별자 생성 기능
생성 방식
- 직접 생성
    - 생성 주체 = 사용자 ( 구현 필요 X )
- 도메인 로직으로 생성
    - 생성 주체 = 도메인
- DB 이용
    - 생성 주체 = DB

## 도메인 구현과 DIP
도메인 모델에 JPA 기술 관련 어노테이션을 사용 = 도메인이 인프라에 의존하는 것

하지만 도메인 모델의 구현 기술이 바뀌는 가능성이 낮기 떄문에, 복잡도를 낮추기 위해 어느정도 타협할 수는 있음


# 5. 스프링 데이터 JPA를 이용한 조회 기능

## 시작에 앞서
### CQRS
명령 모델과 조회 모델을 분리하는 패턴
- 명령 모델 : 상태를 변경 ( write )
- 조회 모델 : 데이터 조회 ( read )

## 검색을 위한 스팩
스펙
- 검색 조건 조합 시, 사용할 수 있는 인터페이스
- 애그리거트가 특정 조건을 충족하는지 검사
- 직접 구현하는 것은 조회 성능에 문제 -> 사용하는 기술에 맞춰야 함

## 동적 인스턴스 생성
JPQL 사용 시, select 절에 생성할 인스턴스 지정해서 해당 인스턴스로 조회 결과 받아올 수 있음

## 하이버네이트 @Subselect 사용
`@Subselect`
- 쿼리 결과를 `@Entity` 로 매핑할 수 있는 기능
- `@Immutable` 사용
    - 조회해 온 엔티티의 필드 / 프로퍼티가 변경되어도 DB에 반영되지 않도록
- `@Synchronize` 사용
    - 아직 커밋되지 않은 트랜잭션의 변경 사항을 알 수 있도록
    - 데이터 로딩하기 전에 테이블 변경이 발생하면, 변경 내역 먼저 flush


# 6. 응용 서비스와 표현 영역

## 표현 영역과 응용 영억
사용자와 도메인을 연결해 주는 매개체

## 응용 서비스의 역할
1. 사용자가 요청한 기능 실행
2. 도메인 영역과 표현 영역을 연결
3. 도메인 객체 간의 흐름을 제어
    - 단순히 도메인 기능을 실행하고, 결과를 리턴
    - 응용 서비스가 복잡하다 = 응용 서비스에서 도메인 로직을 구현하고 있을 가능성
4. 트랜잭션 처리
5. 접근 제어
6. 이벤트 처리

## 응용 서비스의 구현
표현 영역과 도메인 영역을 연결하는 매개체 역할
- 디자인 패턴의 파사드 역할
    - 파사드 패턴 : 여러 저수준 인터페이스들을 하나의 고수준 인터페이스로 묶어줌

### 응용 서비스의 크기
1. 한 응용 서비스에 도메인의 모든 기능 구현
    - 각 기능의 동일 로직에 대해 코드 중복 제거 가능
    - 관련 없는 코드가 섞여 코드 이해 방해 가능
2. 기능 별 응용 서비스 따로 구현
    - 클래스 개수는 많아지지만, 서로 영향을 받지 않음
    - 동일 로직은 별도 클래스에 구현해서 코드 중복 방지 가능

### 값 리턴
애그리거트 자체를 리턴하면, 도메인 로직 실행을 표현 영역에서도 할 수 있게 됨 -> 응용 서비스는 표현 영역에서 필요한 데이터만 리턴하도록

### 표현 영역에 의존성 제거
`HttpServletRequest` 나 `HttpSession` 등 표현 영역에 관련된 타입이 응용 서비스에 전달되면 안 됨
- 표현 영역이 변경되면 응용 서비스도 변경되어야 함
- 응용 서비스가 표현 영역의 역할까지 대신하는 상황이 생길 수 있음

## 표현 영역
1. 사용자에게 화면을 제공, 제어
2. 사용자의 요청을 알맞은 응용 서비스에 전달, 결과를 사용자에게 제공
3. 사용자의 세션 관리

## 값 검증
표현 영역, 응용 서비스 두 곳에서 수행 가능
- 필요 시, 역할 구분 가능   
    - 표현 영역 : 필수 값, 값 형식만 검사
    - 응용 서비스 : 논리적 오류만 검사

## 권한 검사
표현 영역, 응용 서비스 두 곳에서 수행 가능
- 표현 영역 : 인증된 사용자인지 아닌지
    - 서블릿 필터 등에서 접근 제어 가능
- 응용 서비스 : 메서드 단위 권한 검사


# 7. 도메인 서비스

## 도메인 서비스

### 도메인 서비스
도메인 영역에 위치한 도메인 로직을 표현할 때 사용
- 주로 사용하는 상황
  - 여러 애그리거트가 필요하거나, 한 애그리거트에 넣기에는 복잡한 로직
  - 외부 시스템 연동이 필요한 도메인 로직

<details>
<summary>샘플 코드</summary>

```java
/**
 * service
 */
public class Aggregate1Service {

    private final DomainService domainService;
    private final ExternalChecker externalChecker;

    public boolean test(int id) {

        Aggregate2 agg2 = find(id);
        Aggregate1 agg = new Aggregate1();

        return externalChecker.check(agg.testAgg1(domainService, agg2));
    }
}

/**
 * domain
 */
public class Aggregate1 {

    private String id;
    private Aggregate1Sub sub;

    public String testAgg1(DomainService domainService, Aggregate2 agg2) {

        return domainService.testDomain(this.sub, agg2);
    }

    public static class Aggregate1Sub {

        private String name;

        public String getName() {

            return this.name;
        }
    }
}

public class Aggregate2 {

    private int id;
    private Aggregate2Sub sub;

    public Aggregate2Sub getSub() {

        return this.sub;
    }

    public static class Aggregate2Sub {

        private String name;

        public String getName() {

            return this.name;
        }
    }
}

public class DomainService { // 여러 애그리거트가 필요한 계산 로직

    public String testDomain(Aggregate1.Aggregate1Sub agg1Sub, Aggregate2 agg2) {

        return agg1Sub.getName()+agg2.getSub().getName();
    }
}

public interface ExternalChecker { // 외부 시스템 연동
    
    boolean check(String name);
}

/**
 * repository
 */
public class ExternalCheckerImpl implements ExternalChecker {
    
    @Override
    boolean check(String name) {
        
        return true;
    }
}
```
</details>

# 8. 애그리거트 트랜잭션 관리

## 트랜잭션
트랜잭션마다 리포지토리는 새로운 애그리거트 객체를 생성
- 같은 애그리거트를 조회하더라도, 각 트랜잭션마다는 다른 객체로 접근
- 각 트랜잭션의 커밋 전 변경사항이 발생하면, 애그리거트의 일관성이 깨질 수 있음

트랜잭션 처리 기법이 필요
- 선점 잠금
- 비선점 잠금

## 선점 잠금
먼저 애그리거트를 구한 스레드가 사용이 끝날 때까지 다른 스레드가 수정하지 못하게 막음
- 나중에 접근하려는 스레드는 선점한 스레드가 잠금을 해제할 때까지 블로킹
- 일반적으로 DBMS가 제공하는 행 단위 잠금 사용
- JPA는 `@Lock` 어노테이션 사용해서 잠금 모드 지정 가능

교착 상태가 발생하지 않도록 주의
- ex
  ```
  상황 : 애그리거트 A, B 존재

  1. [스레드 1] A 애그리거트에 대한 선점 잠금 구함 (A 잠금 선점)
  2. [스레드 2] B 애그리거트에 대한 선점 잠금 구함 (B 잠금 선점)
  3. [스레드 1] B 애그리거트에 대한 선점 잠금 시도 (B 접근 대기, A 잠금 선점)
  4. [스레드 2] A 애그리거트에 대한 선점 잠금 시도 (A 접근 대기, B 잠금 선점)
  ...

  결과 : 두 스레드 모두 다음 단계를 진행하지 못하고 교착 상태에 빠짐
    - 스레드 1 : B 대기 상태에서 트랜잭션이 끝나지 않음
    - 스레드 2 : A 대기 상태에서 트랜잭션이 끝나지 않음
  ```
- 최대 대기 시간을 지정해야 함
  - JPA는 `@QueryHints` 어노테이션 사용해 쿼리 힌트로 대기 시간 지정 가능

선점 잠금으로 모든 문제가 해결되는 것은 아님
- 여러 트랜잭션이 개입된 기능의 경우, 각 트랜잭션 사이에 데이터 변경이 일어나면 해결 불가능

## 비선점 잠금
변경한 데이터를 실제 DBMS에 반영하는 시점에 변경 가능 여부 확인
- 현재 버전과 동일한 경우에만 데이터 업데이트
- JPA는 `@Version` 어노테이션 사용해서 버전 체크 가능

루트 외 엔티티만 변경될 때, 루트 엔티티는 변경되지 않으므로 버전 값 갱신되지 않는다면 문제 발생
- 엔티티를 구할 때 강제로 버전 증가시키는 잠금 모드 존재

## 오프라인 선점 잠금
여러 트랜잭션의 동시 변경을 막음
- 첫 번째 트랜잭션에서 오프라인 잠금 선점, 마지막 트랜잭션에서 잠금 해제, 잠금 해제 전까지 다른 사용자는 잠금을 구할 수 없음

# 9. 도메인 모델과 바운디드 컨텍스트
같은 용어라도 하위 도메인마다 의미가 다르고, 같은 대상이라도 하위 도메인마다 용어가 다를 수 있음

## 바운디드 컨텍스트
구분되는 경계를 갖는 컨텍스트
 
한 개의 바운디드 컨텍스트가 여러 하위 도메인을 포함하더라도, 하위 도메인마다 구분되는 패키지를 갖도록 해야 함

바운디드 컨텍스트는 도메인 모델을 구분하는 경계 -> 하위 도메인에 맞는 모델을 포함
- 같은 사용자라도 주문 컨텍스트의 사용자 / 회원 컨텍스트의 사용자 가 다름

도메인 기능을 사용자에게 제공하는 데 필요한 표현, 응용 서비스, 인프라 영역을 모두 포함
- 각 컨텍스트마다 다른 구현 기술을 사용할 수도 있음

바운디드 컨텍스트 통합
- 직접 통합 : REST API 호출 등
  - API 사용자가 공급자에 의존
  - 제공 : 상류 컴포넌트
  - 사용 : 하류 컴포넌트
- 간접 통합 : 메세지 큐 사용

컨텍스트 맵
- 바운디드 컨텍스트 간의 관계 표시