# 토비의 스프링 3.1 Vol.1
- Vol.1
    - [1. 오브젝트와 의존관계](#1-오브젝트와-의존관계)
    - [2. 테스트](#2-테스트)
    - [3. 템플릿](#3-템플릿)
    - [4. 예외](#4-예외)
    - [5. 서비스 추상화](#5-서비스-추상화)
    - [6. AOP](#6-aop)

# 1. 오브젝트와 의존관계
## DAO의 분리
객체 지향 기술은 추상세계 자체를 효과적으로 구성하고, 변경, 발전, 확장시킬 수 있다는 점에 의미가 있음
    -> 변화에 어떻게 대비할 것인가가 가장 중요
    => **분리**와 **확장**을 고려해서 설계해야 함

### 관심사의 분리
관심이 같은 것은 모이게 하고, 관심이 다른 것은 떨어져서 영향을 주지 않도록 분리

1. 관심사항 파악
    * 책의 예시의 경우, UserDao 의 관심사항 정리
2. 중복 코드의 메소드 추출
    * DB의 변경 등으로 코드 수정이 필요할 경우, 추출한 메소드 한 개만 변경해도 이슈 없도록 중복 코드 분리
3. 변경 사항 검증 - 리팩토링과 테스트
    * 리팩토링 : 기존의 코드를 외부의 동작 방식에는 변화 없이, 내부 구조를 변경해서 재구성하는 작업

### 상속을 통한 확장
사용처에서 자유롭게 변화가 가능하도록 하는 코드 작성

#### 디자인 패턴
* 설계 시 자주 만나는 문제를 해결하기 위해 사용할 수 있는 재사용 가능한 솔루션
* 대부분 클래스 상속 또는 오브젝트 합성의 구조로 확장성 추구
* 예시
    * 템플릿 메소드 패턴 : 슈퍼클래스에 기본 로직 흐름을 만들고, 기능의 일부를 추상 메소드나 protected 메소드로 생성 후 서브클래스에서 구현해서 사용하는 패턴
    * 팩토리 메소드 패턴 : 서브클래스에서 구체적인 오브젝트 생성 방법을 결정하게 하는 패턴

#### 상속의 한계점
* 다중상속 불가능 : 한 번 상속을 하면, 추후 다른 목적을 위한 상속이 불가능
* 클래스 간 밀접한 관계 : 서브클래스가 슈퍼클래스의 기능을 직접 사용 -> 슈퍼클래스 내부 변경이 서브클래스에 영향을 미침
* 서브클래스들의 코드 중복 : 한 슈퍼클래스를 상속하는 서브클래스가 많아지면, 상속을 통해 만들어진 구현 코드가 모든 서브클래스마다 중복

## DAO의 확장
클래스 사이의 불필요한 의존관계를 제거해야 함
    - 예시의 UserDao 내에 DB 커넥션을 만드는 코드가 있거나, ConnectionMaker 구현체를 지정하는 것은 불필요한 의존관계가 생기는 것
    - UserDao 안이 아닌, 외부에서 UserDao가 사용할 Connection Maker 구현체를 지정하여 주입해줘야 함

### 원칙과 패턴
객체지향 설계 원칙 (SOLID)
- 단일 책임 원칙 (SRP : SIngle Responsibility Principle)
- 개방 폐쇄 원칙 (OCP : Open-Closed Principle)
    - 클래스나 모듈은 확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다
    - 높은 응집도 : 하나의 모듈, 클래스가 하나의 책임, 관심사에만 집중
    - 낮은 결합도 : 책임, 관심사가 다른 오브젝트 또는 모듈 간에는 느슨하게 연결
- 리스코프 치환 원칙 (LSP : Liskov Substitution Principle)
- 인터페이스 분리 원칙 (ISP : Interface Segregation Principle)
- 의존관계 역전 원칙 (DIP : Dependency Inversion Principle)

전략 패턴 : 변경이 필요한 알고리즘은 인터페이스를 통해 외부로 분리, 그 구현체를 필요에 따라 바꿔 사용할 수 있도록 함

## 제어의 역전 (IoC)
### 팩토리
- 객체 생성 방법을 결정하고, 생성된 오브젝트를 돌려주는 것
- 오브젝트 생성자, 사용자 분리 목적

### 제어관계 역전
- 자신이 사용할 오브젝트를 직전 선택하지도, 생성하지도 않음
- 제어의 권한을 다른 대상에게 위임

## 스프링의 IoC
### 빈
스프링이 제어권을 가지고 있는 오브젝트

### 빈 팩토리
빈의 생성과 관계 설정 등의 제어를 담당하는 IoC 오브젝트
스프링 IoC 담당하는 핵심 컨테이너

### 애플리케이션 컨텍스트
일종의 빈 팩토리 (빈 팩토리를 확장한 IoC 컨테이너)
별도의 설정정보 가져와서 빈 생성, 관계 설정 등의 제어 작업 총괄하는 범용적인 IoC 엔진
빈 이름 기반으로 오브젝트 생성 -> 같은 타입의 오브젝트도 빈 이름을 다르게 해서 생성하는 방식, 구성을 다르게 할 수 있음

#### 장점
- 클라이언트는 구체적인 팩토리 클래스를 알 필요 없음
- 종합 IoC 서비스 제공
    - 오브젝트 생성 방식, 시점, 전략 등 설정 가능
    - 자동 생성, 오브젝트 후처리, 정보 조합, 설정 방식 다변화, 인터셉팅 등 기능 제공
    - 외부 시스템 연동을 컨테이너 차원에서 제공
- 빈을 찾는 다양한 방법 제공
    - 빈 이름 외 방법으로도 검색 가능

### 설정정보 / 설정 메타정보
애플리케이션 먼텍스트 또는 빈 팩토리가 IoC 적용하기 위해 사용하는 메타 정보

### 컨테이너 / IoC 컨테이너
애플리케이션 컨텍스트나 빈 팩토리를 컨테이너 / IoC 컨테이너라고도 함 : IoC 방식으로 빈을 관리한다

## 싱글톤 레지스트리와 오브젝트 스코프
스프링은 빈을 싱글톤으로 생성
-> 애플리케이션 컨텍스트는 싱글톤을 저장하고 관리하는 싱글톤 레지스트리이기도 함

요청이 올 때마다 매번 다른 객체를 생성하면 성능 이슈

#### 싱글톤 패턴
애플리케이션 내에서 어떤 클래스를 제한된 개수만큼 존재하게 강제
- 한계
    - 생성자를 private 으로 해서 클래스 밖에서 생성하지 못하도록 함 -> 상속이 불가능
    - 생성 방식이 제한적 -> 테스트 시 목 오브젝트 등으로 대체가 힘듦
    - 서버 환경에서 단일 클래스만 만들어진다고 보장할 수 없음
    - 스태틱 메소드를 통해 언제든 접근 가능 -> 전역 상태로 사용됨 -> 어디서든 자유롭게 접근
- 이런 한계들 때문에 안티 패턴으로 불리기도 함

### 싱글톤 레지스트리
싱글톤 패턴을 따르지 않는 평번한 자바 클래스도 싱글톤 방식으로 생성, 관리할 수 있도록 함

#### 주의점
- 무상태 방식으로 생성되어야 함
    - 여러 스레드에서 접근 가능 -> 여러 곳에서 Read/Write
    - 상태 정보를 내부에 갖고 있지 않은 무상태 방식으로 만들어져야 함

### 빈 스코프
빈이 생성, 존재, 적용되는 범위
스프링 빈은 대부분 싱글톤 스코프이지만, 경우에 따라 다를 수 있음
- 프로토타입 스코프 : 빈 요청할 때마다 새로운 오브젝트 반환
- 요청 스코프 : HTTP 요청마다 새로운 오브젝트 반환
- 세션 스코프 : 웹의 세션과 유사

### 의존관계
방향성이 존재 -> 누가 누구에게 의존하고 있음
의존대상이 변하면 의존하고 있는 쪽이 영향을 받음
인터페이스를 통한 의존관계를 제한 -> 변경에서 자유로움

의존 오브젝트 : 런타임 시에 의존관계를 맺음
- 각 오브젝트 간의 의존관계가 설계, 코드 상에는 드러나지 않음
- 런타임 시의 의존관계는 컨테이너나 팩토리 같은 제3자가 결정

## 의존관계 주입 (DI)
오브젝트 레퍼런스를 외부로부터 제공받고, 이를 통해 타 오브젝트들과 관계를 만듦
DI 컨테이너에 의해 런타임 시 오브젝트 레퍼런스를 전달받는 과정

### 메소드를 이용한 의존관계 주입
- 수정자 메소드(setter) 이용
- 일반 메소드 이용

### 의존관계 검색(DL)
스스로 검색해서 의존관계를 맺는 방법
- ex) getBean()
코드 안에 팩토리 클래스, 스프링 API가 나타남 (이것도 결국 성격이 다른 오브젝트에 의존하는 것)

### XML을 이용한 설정
자바 클래스를 사용하지 않는 의존관계 설정 정보 관리 방법 중 하나
- `<beans>` == @Configuration : 여러 빈을 담을 수 있음
- `<bean>` == @Bean
- `<property>` : 주입하는 오브젝트

# 2. 테스트
## UserDaoTest 다시 보기
테스트의 관심이 다르다면, 테스트할 대상을 분리하고 집중해서 접근

### 단위 테스트
작은 단위의 코드에 대해 테스트를 수행한 것
- 단위는 작을수록 좋다
- 테스트는 자동화, 빠르게 실행 가능해야 함

## UserDaoTest 개선
코드에 큰 변화가 일어나더라도, 테스트 수행으로 정상 동작 확인 가능

## 개발자를 위한 테스팅 프레임워크 JUnit
### Junit
테스팅 프레임워크

단위 테스트는 항상 일관성 있는 결과가 보장되어야 함
테스트는 포괄적으로 작성해야 함
- 문제가 있는 코드인데도 테스트가 성공하게 만드는 것은 위험
- 충분한 검증이 필요

### 테스트 주도 개발
테스트 코드를 먼저 만들고, 테스트를 성공하게 해주는 코드를 작성
테스트 작성 ~ 성공 코드 작성 작업의 주기를 가능한 짧게 가져가도록 권장

### 테스트 코드 개선
중복되는 코드는 `@Before`, `@After` 등 어노테이션을 setUp() 등의 메소드에 추가해서 분리 가능

### 픽스쳐
테스트를 수행하는 데 필요한 정보, 오브젝트

## 스프링 테스트 적용
빈이 많아질수록 어플리케이션 컨텍스트 생성 시간이 오래 소요 -> 생성 방식을 정해주어야 함
JUnit은 기본적으로 테스트 메소드 실행할 때마다 새로운 테스트 오브젝트를 생성
- 단, 어플리케이션 컨텍스트처럼 생성에 시간과 자원이 많이 소모되는 경우, 테스트 전체가 공유하는 오브젝트 생성하기도 함
`@RunWith`, `@ContextConfiguration` 어노테이션으로 어플리케이션 컨텍스트 관리 가능

### Autowired
변수 타입과 일치하는 빈을 찾아 주입 ( 생성자, 수정자 등 메소드 없이도 주입 가능 )

### DI와 테스트
구현체가 아닌 인터페이스를 두고 DI 적용해야 함
- 소프트웨어 개발에서 절대 바뀌지 않는 것은 없음
- 구현 방식이 바뀌지 않더라도, 인터페이스를 두면 다른 차원의 서비스 기능을 도입할 수 있음
- 빠르게 동작하는 테스트 코드를 위해, 범위를 가능한 한 작은 단위로 지정해야 함

## 학습 테스트로 배우는 스프링
프레임워크나 라이브러리 등에 대해 테스트를 작성해 방법을 익힘

### 버그 테스트
코드에 오류가 있을 때 오류를 드러낼 수 있는 테스트
실패하는 테스트 작성 -> 코드 수정 -> 테스트 성공 확인

# 3. 템플릿
개방 폐쇄 원칙(OCP) : 변화의 특성이 다른 부분을 구분해서 독립적으로 변경될 수 있도록 함

## 다시 보는 초난감 DAO
기능 수행 중 예외가 발생해도 리소스를 반환해야 함
-> try/catch/finally 구문 권장
- finally에서 리소스 반환
- 리소스 반환 시, null 체크 후 반환

## 변하는 것과 변하지 않는 것
변하지 않지만 중복되는 코드 / 로직에 따라 자주 변하는 코드 -> 분리 필요
먼저 변하는 성격이 다른 부분 찾고, 분리
- 메소드로 추출
- 템플릿 메소드 패턴 적용
    - 템플릿 메소드 패턴 : 상속을 통해 기능을 확장해서 사용
    - 변하지 않는 부분은 슈퍼클래스에 구현, 변하는 부분은 추상 메소드로 정의 후 서브 클래스에서 오버라이딩
- 전략 패턴 적용
    - 전략 패턴 : 오브젝트를 분리, 클래스 레벨에서 인터페이스를 통해서만 의존
    -  일정한 구조를 갖고 동작하다가, 특정 확장 기능은 독립된 전략 클래스에 위임
    - ```java
        public interface Movable {
            public void move();
        }

        public class Train implements Movable{
            public void move(){
                System.out.println("선로를 통해 이동");
            }
        }        

        public class Bus implements Movable{
            public void move(){
                System.out.println("도로를 통해 이동");
            }
        }


        public class Client {
            public static void main(String args[]){
                Movable train = new Train();
                Movable bus = new Bus();

                train.move();
                bus.move();
            }
        }
- DI 적용을 위한 클라이언트/컨텍스트 분리
    - 클라이언트가 전략 선택, 오브젝트 생성, 컨텍스트에 전달
    - 컨텍스트는 전달받은 오브젝트 사용

### 마이크로 DI
DI의 장점을 단순화, IoC 컨테이너 도움 없이 코드 내에서 적용한 경우
- (스프링 bean 같은 DI 말고, 코드 상에 DI 방식을 사용한 것)

## 스프링의 JdbcTemplate
### queryForInt
결과값을 integer로 받음

### queryForObject
결과값이 row 하나일 때 object로 받음
결과가 없을 때 예외 발생

### query
결과값이 row 여러개일 때 지정한 타입으로 받음
결과가 없을 때 빈 List 반환

# 4. 예외
## 초난감 예외처리
예외 발생 시, 아무것도 해주지 않거나 단순히 출력하는 건 예외를 처리한 것이 아님

## 예외의 종류와 특징
### Error
시스템 문제 ( 주로 자바 VM에서 발생시킴 )
애플리케이션의 관심사가 아님

### Exception, 체크 예외
체크 예외 : RuntimeException을 상속하지 않은 것
- 예외 처리 강제
- 처리하지 않으면 컴파일 시 에러 발생

### RuntimeException, 언체크/런타임 예외
언체크 예외 : RuntimeException을 상속한 것
- 예외 처리 강제하지 않음
- 처리하지 않으면 런타임에 에러 발생

## 예외처리 방법
- 예외 복구 : 정상 상태로 돌려놓기
    - ```java
        void test(int maxRetry) {
            while(maxRetry-- > 0) {
                try {
                    ...
                } catch (AException e) {
                    sleep();
                }
            }
            throw new BException();
        }
- 예외처리 회피 : 호출한 쪽으로 예외 그대로 던지기
    - ```java
        void test() throws Exception { ... }
- 예외 전환 : 적절한 예외로 전환해서 외부에 던지기
    - ```java
        void test() {
            try {
                ...
            } catch (AException e) {
                throw new BException(e); // 중첩 예외
            } catch (CException e) {
                throw new RuntimeException(e); // 예외 포장
            }
        }

런타임 에러의 보편화
- 사용자들이 여러 요청 시, 한 요청에서 예외 발생하면 해당 작업만 중지
- 대응 불가능한 체크 예외는 런타임 예외로 전환해서 던지는 게 낫다
    - 대응 불가능한 체크 예외 = throws Exception 메소드만 늘어남

어플리케이션 예외
- 로직에서 의도적으로 발생시키고, 반드시 catch 해야하는 예외
- 설계 방법
    1. 정상 동작 / 예외 케이스에 다른 종류의 값 리턴
        - ```java
            int test(SomeRequest request) {
                if (request.invalid()) {
                    return -1;
                }
                return 1;
            }
    2. 비즈니즈적 의미를 가진 예외 발생
        - ```java
            int test(SomeRequest request) {
                if (request.invalid()) {
                    throw new BusinessException();
                }
                return 1;
            }

## 예외 전환
### DB 에러 코드 매핑을 통한 전화
SQLException 발생 시, 각 에러 코드마다 의미가 드러나는 예외로 전환 가능
- DB마다 에러 코드가 다름 -> DB 별 에러 코드를 분류, DB에 독립적인 예외로 매핑 가능
- ```xml
    <bean id="Oracle" class="org.springframework.jdbc.support.SQLErrorCodes">
        <property name="badSqlGrammarCodes">
            <value>900, 903, 904</value>
        </property>
    </bean>
    ```

### 기술에 독립적인 UserDao 만들기
인터페이스 적용, 구현 클래스 개발 시 기술 적용

# 5. 서비스 추상화
## 사용자 레벨 관리 기능 추가
사용자 관리 로직 등은 UserDaoJdbc 등과 같이 데이터 조작을 위한 클래스가 아닌 비즈니스 로직을 담을 별도 클래스에 구현해야 함

## 트랜잭션 서비스 추상화
테스트 시, 예외 발생시켜야 한다면 테스트용 서비스 생성, 메소드 오버라이딩
```java
static class TestUserService extends UserService {
    private String id;

    private TestUserService(String id) {
        this.id = id;
    }

    /*
    특정 조건에서 예외 발생하도록 기존 메소드 오버라이딩
    테스트를 위해 어플리케이션 코드를 바꾸지 않고 테스트용에서만 변경
    */
    @Override
    protected void upgradeLevel(User user) { 
        if (user.getId().equals(this.id)) throw new Exception();
        super.upgradeLevel(user);
    }
}
```

## 트랜잭션 경계설정
여러 SQL 사용되는 작업이 하나의 트랜잭션으로 묶일 수 있음

트랜잭션 경계 설정
- 트랜잭션의 시작 선언하고, 롤백(모든 작업 무효화) 또는 커밋(모든 작업 확정) 으로 종료하는 작업
- 문제점
    - JdbcTemplate 사용 불가
    - UserService 는 비즈니스 로직을 담고 있는 클래스지만 Connection 파라미터가 존재해야 함
    - UserDao 가 데이터 액세스 기술에 독립적이지 않게 됨
    - 테스트 코드에서 Connection 오브젝트를 만들어 호출해야 함

## 트랜잭션 동기화
Connection 파라미터 전달할 필요 없이, 별도 저장소에 보관해두고, 이후 호출되는 DAO 메소드에는 저장된 Connection을 가져다가 사용

스프링
- `TransactionSynchronizationManager` 클래스 통해 트랜잭션 동기화 작업

JdbcTemplate
- 미리 생성되어 저장소에 등록된 DB 커넥션이나 트랜잭션 없는 경우, JdbcTemplate 이 직접 DB 커넥션 만들고 시작
- 트랜잭션 동기화가 시작된 경우, 저장소에서 DB 커넥션을 가져와서 사용 = 이미 시작된 트랜잭션에 참여

## 트랜잭션 서비스 추상화
### 글로벌 트랜잭션
각 DB와 독립적으로 만들어지는 Connection이 아닌, 별도 트랜잭션 관리자를 통해 트랜잭션을 관리
- 자바는 JTA 등 제공

스프링
- 트랜잭션 경계설정 추상 인터페이스인 `PlatformTransactionManager`
- 기술 별 `PlatformTransactionManager` 구현한 트랜잭션 매니저 사용

## 서비스 추상화와 단일 책임 원칙
비즈니스 로직 / 하위 로우레벨 트랜잭션 기술 등 다른 계층의 특성을 갖는 코드 분리
수별적 / 수직적 모두 결합도를 낮추기 위해 DI 가 중요한 역할
- 관심, 책임, 성격이 다른 코드를 깔끔하게 분리

### 단일 책임 원칙
하나의 모듈은 하나의 책임을 가진다
- 변경 필요 시, 수정 대상 명확

## 메일 서비스 추상화
### JavaMail을 이용한 메일 발송 기능
JavaMail
- 자바 이메일 클래스
- 메일 전송 서버에 전송 요청 보냄

### JavaMail이 포함된 코드의 테스트
- 메일 전송 서버는 충분히 검증된 서비스
- JavaMail API 통해 요청이 들어간다는 것만 확인하면 실제 메일이 전송되는지 여부는 테스트 필요 X

### 테스트를 위한 서비스 추상화
- JavaMail은 확장, 지원 불가능한 표준 API
- 쉽게 테스트하기 위해 JavaMail에 대한 추상화 기능 제공 ex. `MailSender`
- 트랜잭션 적용 방식
    - 트랜잭션 작업 완료 시 메일 전송
    - 메일 전송에 트랜잭션 개념 적용

## 테스트 대역
테스트 대상이 의존하는 오브젝트를 DI를 통해 변경

### 테스트 대역
자주 테스트를 수행할 수 있도록 테스트 대상이 되는 오브젝트 기능 빠르게 수행 가능하도록 한 오브젝트

### 테스트 스텁
테스트 대상 오브젝트의 의존객체

### 목 오브젝트
실제 기능은 없고, 코드가 수행되도록 넘겨주는 출력 값만 보관해서 리턴하는 등 수행

# 6. AOP
## 트랜잭션 코드의 분리
1. 트랜잭션 경계 설정의 코드 / 비즈니스 로직 코드 간 주고받는 정보 없음 -> 메소드 분리 가능
2. 기술적인 코드 / 로직적인 코드 분리 -> 클래스 분리
3. 구현 클래스에 의존적인 강한 결합 -> 약한 결합을 갖도록 DI 적용
4. 테스트 수정

## 고립된 단위 테스트
- 의존관계가 복잡하면 작은 단위의 테스트가 어려움
- 목 오브젝트 - 테스트를 의존 오브젝트, 서버 등에서 고립시킴

## 다이내믹 프록시와 팩토리 빈
- 핵심기능은 부가기능 클래스의 존재를 모름, 부가기능이 핵심기능을 사용하는 구조가 되어야 함
- 부가기능은 자신이 핵심기능 클래스인 것처럼 꾸며서, 클라이언트가 자신을 거쳐 핵심기능을 사용하도록 해야 함
- 부가기능은 핵심기능으로 요청을 위임하는 과정에서 자신이 가진 부가기능을 적용

### 프록시
클라이언트가 사용하려고 하는 실제 대상인 것처럼 위장해서 요청을 받아주는 대리자
- 타깃과 같은 인터페이스 구현
- 프록시가 타깃을 제어할 수 있는 위치에 있음

사용 목적
1. 클라이언트가 타깃에 접근하는 방법 제어
2. 타깃에 부가적인 기능 부여

### 타깃 / 실체
프록시를 통해 요청을 위임받아 처리하는 실제 오브젝트

### 데코레이터 패턴
**런타임** 시 타깃에 부가적인 기능을 다이내믹하게 부여하기 위해 프록시를 사용하는 패턴
- 프로시가 한 개로 제한되지 않음 
    - 프록시가 직접 타깃을 사용하도록 고정시킬 필요 없음
    - 순서를 정해 단계적으로 위임하는 구조
- 프록시로 동작하는 데코레이터는 대상에도 인터페이스로 접근 
    - 자신이 접근하는 곳이 최종 타깃인지, 다음 단계 프록시인지 모름
- 타깃의 코드, 클라이언트 호출 방법 변경 없이 새로운 기능 추가 가능

### 프록시 패턴
타깃에 대한 접근 방법을 제어하기 위해 프록시를 사용하는 패턴
- 클라이언트에 타깃에 대한 레퍼런스는 넘겨주면서, 사용할 때까지 생성을 최대한 늦춤
- 다른 서버에 존재하는 원격 오브젝트를 사용하는 경우, 프록시를 만들어두고, 클라이언트는 로컬의 오브젝트를 쓰는 것처럼 프록시 사용 가능

### 프록시 작성의 문제점
1. 타깃의 인터페이스를 구현, 위임하는 코드 작성이 번거로움
    - 부가기능이 필요 없는 메소드까지 구현해야 함
2. 부가기능 코드 중복 가능성이 많음

### 다이내믹 프록시
- 리플렉션 기능을 이용해 프록시를 만들어줌
- 런타임 시 다이내믹하게 만들어지는 오브젝트
- 필요한 부가기능 코드는 프록시 오브젝트와 독립적으로 `InvocationHandler`를 구현한 오브젝트에 작성
    - `invoke()` 메소드 하나만 구현
    - 다이내믹 프록시를 통해 요청이 전달되면, 리플렉션 API 통해 `invoke()` 메소드로 전달

문제점
- DI 대상인 다이내믹 프록시 오브젝트는 일반적인 스프링 빈으로 등록할 수 없음
- 스프링의 빈은 클래스 이름, 프로퍼티로 정의, 리플렉션을 이용해 오브젝트 생성
- 다이내믹 프록시 오브젝트 클래스 자체도 내부적으로 다이내믹하게 새로 정의해서 사용 -> 클래스 정보를 미리 알아서 빈에 정의할 방법이 없음

### 팩토리 빈
스프링을 대신해서 오브젝트의 생성 로직을 담당하도록 만들어진 빈
- 스프링의 `FactoryBean` 인터페이스를 구현하는 등 방법으로 만들 수 있음
- `getObject()` 메소드를 통해 빈으로 사용될 오브젝트 직접 생성

### 프록시 팩토리 빈 빙식의 문제점
- 프록시 팩토리 빈 재사용
    - 타깃의 타입과 상관 없이 재사용 가능
- 프록시 작성의 문제점 해결
    - 타깃 인터페이스 일일히 구현하지 않아도 됨
    - 하나의 핸들러 메소드 구현으로 여러 메소드에 부가기능 부여 가능
- 한 클래스 안의 여러 매소드에 부가기능 한 번에 제공하는 건 가능, 여러  클래스에 부가기능 한 번에 제공하는 건 현재까지 방법으로는 불가능
-  서비스 빈 설정 시, 적용할 모든 부가기능의 프록시 각각 다 추가해줘야 함

## 스프링의 프록시 팩토리 빈
스프링은 일관된 방법으로 프록시를 만들 수 있게 도와주는 추상 레이어 제공

### ProxyFactoryBean
프록시를 생성해서 빈 오브젝트로 등록하게 해주는 팩토리 빈
- 프록시를 생성하는 작업만 담당, 부가기능은 별도의 빈에 둘 수 있음
- 부가기능은 `MethodInterceptor` 인터페이스 구현
    - `MethodInterceptor`의 `invoke()` 메소드는 `ProxyFactoryBean`으로부터 타깃 오브젝트에 대한 정보도 제공 받음
    - 타깃 오브젝트에 상관 없이 독립적으로 만들어질 수 있음 ( 제공받은 정보로 쓰면 되니까 )
    - 일종의 콜백 오브젝트, `proceed()` 메소드 실행하면 타깃 오브젝트의 메소드를 내부적으로 실행해줌

### 어드바이스
타깃이 필요 없는 순수한 부가기능

### 포인트컷
부가기능 적용 대상 메소드 선정 방법
- `MethodInterceptor`는 순수 부가기능 제공 코드만 남기고, 부가기는 적용 메소드 선별하는 기능을 분리

### 어드바이저
포인트컷 + 어드바이스
- `ProxyFactoryBean`에는 여러 포인트컷, 어드바이스 등록 가능
- 어떤 어드바이스에 어떤 포인트컷을 적용할지 애매해지기 때문에 포인트컷, 어드바이스를 조합해서 적용해야 함

## 스프링 AOP
프록시 팩토리 빈 방식의 문제점
1. 부가기능이 타깃 오브젝트마다 생성 -> `ProxyFactoryBean` 어드바이스를 통해 해결
2. 타깃 오브젝트마다 비슷한 `ProxyFactoryBean` 빈 설정정보 추가

### 빈 후처리기
- 스프링 빈 오브젝트로 만들어지고 난 후, 빈 오브젝트를 다시 가공할 수 있음
- `BeanPostProcessor` 인터페이스 구현

`DefaultAdvisorAutoProxyCreator`
- 어드바이저를 이용한 자동 프록시 생성기
- 빈 후처리기 자체를 빈으로 등록, 빈 후처리기가 등록되어 있으면 스프링이 빈 오브젝트 생성될 때마다 빈 후처리기에 후처리 작업 요청
- 빈 후처리기를 통해서 빈 오브젝트 프로퍼티 수정, 초기화, 다른 오브젝트로 바꿔치기 가능
    - 스프링 빈 오브젝트의 일부를 프록시로 포장하고, 프록시를 빈으로 대신 등록
- 프록시 자동생성
    1. 빈으로 등록된 모든 어드바이저 내의 포인트컷을 이용해 전달받은 빈이 프록시 적용 대상인지 확인
    2. 프록시 적용 대상이면, 내장된 프록시 생성기에 현재 빈에 대한 프록시를 만들게 함
    3. 만들어진 프록시에 어드바이저 연결
    4. 프록시 오브젝트를 스프링 컨테이너에 반환
    5. 스프링 컨테이너는 프록시 오브젝트를 빈으로 등록, 사용

### 포인트컷
```java
public interface Pointcut {
    
    ClassFilter getClassFilter();
    MethodMatcher getMethodMatcher();
}
```
- `getClassFilter()` : 프록시 적용 대상 클래스인지 확인
    - 클래스 필터에서 통과하지 못하면 프록시를 만들 필요가 없음 -> 어떤 메소드에도 부가기능이 적용되지 않기 때문
- `getMethodMatcher()` : 어드바이스 적용할 메소드인지 확인

### 포인트컷 표현식
- 표현식 언어를 사용해 포인트컷 작성
- 프레임워크 `AspectJ` 에서 제공하는 것을 가져와 일부 문법 확장해서 사용

포인트컷 지시자를 이용해 작성
- `execution()`
    - `execution([접근제한자 패턴] 타입패턴 [타입패턴.]이름패턴 (타입패턴 | "..", ...) | [throws 예외 패턴])`
        - [접근 제한자 패턴] : `public`, `protected`, `private` ... - 생략 가능
        - 타입패턴 : 리턴 값의 타입 패턴
        - [타입패턴.] : 패키지, 클래스 이름 패턴 -  생략 가능
        - 이름패턴 : 메소드 이름 패턴
        - (타입패턴 | "..", ...) : 파라미터 타입 패턴 순서대로, 와일드카드 사용 가능
        - [throws 예외 패턴] : 예외 이름 패턴 - 생략 가능
    - ex. `execution(public int springbook.learningtest.spring.prointcut.Target.minus(int,int) throws java.lang.RuntimeException)`
- `bean()` : 빈 이름으로 비교
    - ex. `bean(*Service)`
- `annotation()` : 해당 어노테이션이 붙은 모든 메소드
    - ex. `annotation(org.springframework.transaction.annotation.Transactional)`

### AOP
애스펙트 지향 프로그래밍
- 애스펙트 : 어플리케이션의 핵심기능을 담고 있지는 않지만, 핵심기능에 부가되어 의미를 갖는 모듈
- 어드바이저는 아주 단순한 형태의 애스펙트

핵심기능 코드 사이의 부가기능을 독립적인 모듈인 애스펙트로 구분해서 설계, 개발하는 방법
- AOP는 OOP를 돕는 보조적인 기술, OOP를 대체하는 개념이 아님

### AOP 적용 기술
1. 프록시를 이용한 AOP
    - ex. 스프링 AOP : 빈을 프록시로 바꿔주는 간접적인 방법
2. 바이트코드 생성과 조작을 통한 AOP
    - ex. AspectJ : 타깃 오브젝트를 뜯어고쳐 부가 기능을 직접 넣어주는 직접적인 방법 사용
        - 클래스 파일 자체를 수정하거나, 클래스가 JVM에 로딩되는 시점을 가로채서 바이트코드를 조작
        - 스프링과 같은 DI 컨테이너의 도움 없이 AOP 적용 가능
        - 프록시 방식보다 훨씬 강력하고 유연

### AOP 네임스페이스
스프링에서 AOP를 위해 적용되는 빈들(자동 프록시 생성기, 어드바이스, 포인트컷, 어드바이저, ...)을 간편하게 등록
- \<aop:config\>, \<aop:pointcut\>, \<aop:advisor\> 태그 정의하면 빈 자동 등록
